//! A library that handles caching rendered glyphs on the GPU
//!
//! This fits as a layer in your rendering pipeline between font rasterization and shaping and text
//! rendering. In other words, first you turn a string into a series of font glyphs. Each of those
//! glyphs is looked up against the cache, and if it hasn't been rendered, it is turned into a
//! bitmap and uploaded to the GPU. The string is laid out
//!
//! Scope of this library:
//! - DO support various font libraries / types of fonts (rusttype / fontdue for TTFs, bitmap fonts
//! of various types)
//! - DO support various types of graphics backends (GL, wgpu, vulkan, various higher-level
//! frameworks)
//! - DON'T handle complex tasks like shaping. The font stack should handle that elsewhere, and
//! provide this library the glyphs to render
//! - DON'T handle layout or rendering to the screen. This can be taken care of

#[cfg(feature = "image")]
mod image_impl;
#[cfg(feature = "rusttype")]
mod rusttype_impl;

// TODO: handle whitespace inside the string
// TODO: texture too small
// TODO: going to want a better hashmap
use std::collections::HashMap;

/// Any object that can turn characters into glyphs and render them can be a FontProvider
///
/// FontProviders can be TTF font rasters, like rusttype (a pure-Rust library for decoding fonts) or
/// fontkit (a library that delegates to system APIs to handle fonts). Other FontProviders could
/// include bitmap fonts, or a combination of libraries (like a library to handle shaping and
/// another library to handle rendering.)
pub trait FontProvider {
    /// If this font supports vertical layout (e.g. some Japanese fonts)
    fn supports_vertical(&self) -> bool;
    /// The format of the data generated by the FontProvider
    fn pixel_type(&self) -> PixelType;
    /// Convert the string into glyphs, and push the glyphs into the provided buffer
    fn glyphs(&self, string: &str, glyphs: &mut Vec<Glyph>);
    /// In a vertical font, how much space to include between font baselines
    fn line_width(&self, size: f32) -> f32;
    /// In a horizontal font, how much space to include between font baselines
    fn line_height(&self, size: f32) -> f32;
    /// Get the metrics of a character (how to space it, where to include it on a line, etc.)
    fn metrics(&self, key: GlyphKey) -> Metrics;
    /// Convert a character into image bytes, with the format determined by [`pixel_type`]
    ///
    /// [`pixel_type`]: FontProvider::pixel_type
    fn rasterize(&self, key: GlyphKey) -> Vec<u8>;
}

/// Any object that can take the data for glyphs and store it over time
///
/// Textures can be image buffers on the CPU (like ones provided by the image crate) or a buffer
/// on the GPU, through any graphics library.
pub trait Texture {
    fn width(&self) -> u32;
    fn height(&self) -> u32;
    /// Write the data from a font into a texture
    fn put_rect(&mut self, pixel: PixelType, data: &[u8], gpu: &TextureGlyph);
}

/// The main structure for maintaing a cache of rendered glyphs
///
/// `FontCache` is specifically an intermediary step. It doesn't understand how to read font files
/// or how to break up a string into glyphs: that's handled by the [`FontProvider`]. It doesn't
/// handle sending glyphs to the GPU: if you want to do that, provide a [`Texture`] that stores its
/// data on the GPU. What it does do is keep track of which glyphs have already been rendered, where
/// they were stored, and provide a consistent API over a variety of ways of rendering characters.
pub struct FontCache<T: Texture> {
    glyph_buffer: Vec<Glyph>,
    cache: Cache<T>,
}

struct Cache<T: Texture> {
    font: Box<dyn FontProvider>,
    texture: T,
    map: HashMap<GlyphKey, TextureGlyph>,
    h_cursor: u32,
    v_cursor: u32,
    current_line_height: u32,
}

// TODO: probably add a better packing algorithm

impl<T: Texture> FontCache<T> {
    /// Create a new FontCache that pulls from the given provider and renders to the provided
    /// texture
    pub fn new(font: Box<dyn FontProvider>, texture: T) -> Self {
        FontCache {
            glyph_buffer: Vec::new(),
            cache: Cache {
                font,
                texture,
                map: HashMap::new(),
                h_cursor: 0,
                v_cursor: 0,
                current_line_height: 0,
            },
        }
    }

    /// Forget the position of the characters in the texture, and re-set the cursor.
    ///
    /// This doesn't set any data in the Texture! Old glyphs may continue to work, but this is akin
    /// to a use-after-free.
    pub fn clear(&mut self) {
        self.cache.clear();
    }

    /// Render a glyph to the texture at a given size
    pub fn render_glyph(&mut self, key: GlyphKey) -> Result<TextureGlyph, CacheError> {
        self.cache.render_glyph(key)
    }

    /// Attempt to convert a string into a series of glyphs or errors
    pub fn render_string<'a>(
        &'a mut self,
        string: &str,
        size: f32,
    ) -> impl 'a + Iterator<Item = Result<TextureGlyph, CacheError>> {
        #[cfg(feature = "unicode-normalization")]
        let mut string = {
            use unicode_normalization::UnicodeNormalization;
            string.nfc().collect::<String>()
        };
        #[cfg(not(feature = "unicode-normalization"))]
        let mut string = string.to_owned();
        string.retain(|c| !c.is_whitespace());
        let size = size.to_bits();
        let glyph_buffer = &mut self.glyph_buffer;
        let cache = &mut self.cache;
        cache.font.glyphs(&string, glyph_buffer);
        glyph_buffer
            .drain(..)
            .map(move |glyph| cache.render_glyph(GlyphKey { glyph, size }))
    }

    /// Cache a string or return an error if one occurred
    ///
    /// This can be useful if the entire domain of the possible glyphs is known beforehand (like a
    /// bitmap font.)
    pub fn cache_string(&mut self, string: &str, size: f32) -> Result<(), CacheError> {
        self.render_string(string, size)
            .map(|r| r.map(|_| ()))
            .collect()
    }

    pub fn texture(&self) -> &T {
        &self.cache.texture
    }

    pub fn font(&self) -> &dyn FontProvider {
        self.cache.font.as_ref()
    }
}

impl<T: Texture> Cache<T> {
    fn clear(&mut self) {
        self.map.clear();
        self.h_cursor = 0;
        self.v_cursor = 0;
        self.current_line_height = 0;
    }

    fn render_glyph(&mut self, key: GlyphKey) -> Result<TextureGlyph, CacheError> {
        if let Some(glyph) = self.map.get(&key) {
            return Ok(*glyph);
        }
        let metrics = self.font.metrics(key);
        if metrics.width > self.texture.width() || metrics.height > self.texture.height() {
            return Err(CacheError::TextureTooSmall);
        }
        if metrics.width + self.h_cursor > self.texture.width() {
            self.h_cursor = 0;
            self.v_cursor += self.current_line_height + 1;
            self.current_line_height = 0;
        }
        if metrics.height + self.v_cursor > self.texture.height() {
            return Err(CacheError::OutOfSpace);
        }
        let pixel_type = self.font.pixel_type();
        let data = self.font.rasterize(key);
        let gpu = TextureGlyph {
            x: self.h_cursor,
            y: self.v_cursor,
            width: metrics.width,
            height: metrics.height,
        };
        self.texture.put_rect(pixel_type, &data[..], &gpu);
        self.h_cursor += gpu.width + 1;
        self.current_line_height = self.current_line_height.max(gpu.height);
        self.map.insert(key, gpu);
        Ok(gpu)
    }
}

/// The index of the font character to render
///
/// Glyphs are what actually gets rendered to the screen. It might be tempting to think of a glyph
/// like a 'rendered character.' In specific scripts, this is often the case. 'A' and 'a' have
/// distinct glyphs, and are unconditionally the same glyph. In others, this might not be true. See
/// ['Text Rendering Hates You'](https://gankra.github.io/blah/text-hates-you) for more information
/// on why text is complicated.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct Glyph(pub u32);

/// A glyph with a size to allow rendering
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct GlyphKey {
    pub glyph: Glyph,
    pub size: u32,
}


/// The relevant information for a glyph stored on the texture
#[derive(Copy, Clone, Debug)]
pub struct TextureGlyph {
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
}

/// The layout information for a glyph
#[non_exhaustive]
pub struct Metrics {
    pub width: u32,
    pub height: u32,
    pub bearing_x: f32,
    pub advance_x: f32,
    pub bearing_y: f32,
    pub advance_y: f32,
}

/// An error generated during a cache operation
#[derive(Debug)]
pub enum CacheError {
    /// No matter what, the texture is too small to render the glyph
    ///
    /// To fix this error, expand the texture. Make sure to clear the cache if the texture data is
    /// also invalidated
    TextureTooSmall,
    /// The cache cannot store the current request without clearing it first
    OutOfSpace,
}

/// How the pixels of the rasterized font are represented
pub enum PixelType {
    /// A series of values representing the alpha with no associated color
    Alpha,
    /// A series of complete color values
    RGBA,
}
